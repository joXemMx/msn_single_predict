# -*- coding: utf-8 -*-
"""
Created on Wed Jul 21 17:11:29 2021

@author: stravsm
"""
from .fp_database import *
from .fp_database import logger
from .fp_database import FpDatabase

import h5py
import re
import numpy as np

class FpDatabaseHdf5(FpDatabase):
    """
    HDF5 database backend. 
    Config options: 
        * process_smiles: if True, generic and canonical SMILES are generated by CDK.
            If False, no SMILES are generated. If smiles_generic and smiles_canonical are already
            in the HDF5 file, those are used; otherwise the non-aromatic SMILES is used verbatim.
        * fingerprints_degraded: if a file is given, this is a set of pre-sampled fingerprints that
            are available as ['fingerprint_degraded'] in the records. 
            If None, there are no fingerprint_degraded provided.
        
    """
    
    
    def __init__(self, db_file, config):
        super().__init__(db_file, None) 
        
        config_ = {
            'use_regex': True,
            'fingerprints_degraded': None,
            'process_smiles': True
            }
        config_.update(config)
        self.config = config_
        self.fingerprinter = fpr.Fingerprinter.get_instance()
        self._load_hdf()
        self.use_regex = self.config['use_regex']

    def _load_hdf(self):
        self.db = h5py.File(self.db_file, 'r')
        # Load predefined sampled FPs if specified
        self.db_degraded = None
        if self.config["fingerprints_degraded"] is not None:
            fp_deg = self.config["fingerprints_degraded"]
            logger.info(f"Loading pre-sampled fingerprints from {fp_deg} into fingerprints_degraded")
            if "fingerprints_degraded" in self.db:
                logger.warn("Overriding the provided fingerprints_degraded from the database")
            self.db_degraded = h5py.File(fp_deg, 'r')
        # Process SMILES to aromatic SMILES if specified
        if self.config["process_smiles"]:
            logger.info("Generating aromatic SMILES")
            self.data = self.fingerprinter.process(self.db["smiles"], calc_fingerprint = False)
            self.smiles_generic = np.array([x["smiles_generic"] for x in self.data])
            self.smiles_canonical = np.array([x["smiles_canonical"] for x in self.data])
        elif "smiles_generic" in self.db:
            logger.info("Using aromatic SMILES from database")
            self.smiles_generic = self.db["smiles_generic"]
            self.smiles_canonical = self.db["smiles_canonical"]
        else:
            logger.info("Not generating aromatic SMILES - using verbatim SMILES")
            self.smiles_generic = self.db["smiles"]
            self.smiles_canonical = self.db["smiles"]
        # Process molecular formulas
        logger.info("Processing molecular formulas (deferred)")
        mf_ = map(self._extract_mf, self.db["mf_text"])
        self.mf = np.array([x for x in mf_])
            
    def _extract_mf(self, mf_text):
        groups = re.findall(r'([A-Z][a-z]*)([0-9]*)', mf_text)
        mf_raw = dict(groups)
        mf = {
            k: max(1, int('0' + v)) for k, v in mf_raw.items()
            }
        return Counter(mf)
        
    def get_grp(self, grp):
        '''
        Parameters
        ----------
        grp : The group name to retrieve from the DB

        Returns
        -------
        An iterable 
            DESCRIPTION.

        '''
        
        if self.use_regex:
            grp_match = map(lambda s: re.match(grp, s) is not None, self.db["grp"])
        else:
            grp_match = map(lambda s: s.startswith(grp), self.db["grp"])
            
        grp_indices = np.where(np.array([x for x in grp_match]))[0]
        
        
        
        if self.db_degraded is not None:
            return [
                self._record_iter(x, grp)
                for x in zip(
                        grp_indices,
                        self.db["fingerprints"][grp_indices],
                        self.db_degraded["fingerprints_degraded"][grp_indices],
                        self.smiles_generic[grp_indices],
                        self.smiles_canonical[grp_indices],
                        self.db["inchikey"][grp_indices],
                        self.db["inchikey1"][grp_indices],
                        # for now we ignore that we have no processed molecules,
                        self.mf[grp_indices],
                        grp_indices)]
        elif "fingerprints_degraded" in self.db:
            return [
                self._record_iter(x, grp)
                for x in zip(
                        grp_indices,
                        self.db["fingerprints"][grp_indices],
                        self.db["fingerprints_degraded"][grp_indices],
                        self.smiles_generic[grp_indices],
                        self.smiles_canonical[grp_indices],
                        self.db["inchikey"][grp_indices],
                        self.db["inchikey1"][grp_indices],
                        # for now we ignore that we have no processed molecules,
                        self.mf[grp_indices],
                        grp_indices)]
        else:
            logger.warning("There are no fingerprints_degraded provided; the full fingerprints will be used for this!")
            return [
                self._record_iter(x, grp)
                for x in zip(
                        grp_indices,
                        self.db["fingerprints"][grp_indices],
                        self.db["fingerprints"][grp_indices],
                        self.smiles_generic[grp_indices],
                        self.smiles_canonical[grp_indices],
                        self.db["inchikey"][grp_indices],
                        self.db["inchikey1"][grp_indices],
                        # for now we ignore that we have no processed molecules,
                        self.mf[grp_indices],
                        grp_indices)]
                    
            
        
    def _record_iter(self, record, grp = None):
        keys = ["id", "fingerprint", "fingerprint_degraded", "smiles_generic", 
                "smiles_canonical", "inchikey", "inchikey1", "mf", "perm_order"]
        record_dict = dict(zip(keys, record))
        if grp is not None:
            record_dict["grp"] = grp
        return record_dict
        
    def get_pipeline_options(self):
        
        options = super().get_pipeline_options()
        options['unpack'] = False
        options['unpickle_mf'] = False
        return options

FpDatabase.register_mapping(".h5", FpDatabaseHdf5)